# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
#  if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
#    source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
#  fi

export EDITOR=nvim

# prompt setup (guarded)
if [ -d "$HOME/.zsh/pure" ]; then
  fpath+=("$HOME/.zsh/pure")
  autoload -U promptinit; promptinit
  prompt pure
else
  echo "pure prompt not found in \$HOME/.zsh/pure; installing with: git clone https://github.com/sindresorhus/pure \$HOME/.zsh/pure" >&2
  mkdir -p "$HOME/.zsh"
  git clone https://github.com/sindresorhus/pure.git "$HOME/.zsh/pure"
  fpath+=($HOME/.zsh/pure)
  autoload -U promptinit; promptinit
  prompt pure
fi

# export ZSH_THEME="arrow"
# export ZSH="$HOME/.oh-my-zsh"

# Install zinit if not already installed
ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"
if [ ! -d "$ZINIT_HOME" ]; then
   mkdir -p "$(dirname $ZINIT_HOME)"
   git clone https://github.com/zdharma-continuum/zinit.git "$ZINIT_HOME"
fi

source "${ZINIT_HOME}/zinit.zsh"

# Load plugins asynchronously
zinit light zsh-users/zsh-syntax-highlighting
zinit light zsh-users/zsh-completions
zinit light zsh-users/zsh-autosuggestions

# $(brew --prefix)/etc/profile.d/z.sh
. ~/github.com/rupa/z/z.sh


# Minimal oh-my-zsh plugins - git is already loaded via zinit
plugins=(
#    aws
#    docker
#    docker-compose
)

# source $ZSH/oh-my-zsh.sh

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# Aliases
alias n="nvim"
alias lfg="export IS_SANDBOX=1 && claude --dangerously-skip-permissions"
alias python="python3"
alias lg="lazygit"
alias gt="git town"
alias l="eza -la"
alias ls="eza"
# Task Master aliases added on 4/18/2025
alias tm='task-master'
alias taskmaster='task-master'
alias tf="terraform"
alias k="kubectl"
alias gl-releasable="/usr/local/bin/git-log-releasable.sh"
alias myip="dig -4 TXT +short o-o.myaddr.l.google.com @ns1.google.com"

# golang
export GOPATH="$HOME/go"
export PATH="/Users/miketobias/.local/bin:$GOPATH/bin:$PATH"

# bun completions
[ -s "/Users/miketobias/.bun/_bun" ] && source "/Users/miketobias/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

# [ -f "/Users/miketobias/.ghcup/env" ] && source "/Users/miketobias/.ghcup/env" # ghcup-env

# yarn
export PATH="$HOME/.yarn/bin:$HOME/.config/yarn/global/node_modules/.bin:$PATH"

# rvm. Add RVM to PATH for scripting. Make sure this is the last PATH variable change.
export PATH="$PATH:$HOME/.rvm/bin"

# postgres
export PATH="/opt/homebrew/opt/postgresql@15/bin:$PATH"

# source /Users/miketobias/.config/op/plugins.sh

# Lazy load nvm for faster shell startup
export NVM_DIR="$HOME/.nvm"
declare -a NODE_GLOBALS=(`find ~/.nvm/versions/node -maxdepth 3 -type l -wholename '*/bin/*' | xargs -n1 basename | sort | uniq`)
NODE_GLOBALS+=("node" "nvm")

load_nvm() {
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
}

for cmd in "${NODE_GLOBALS[@]}"; do
  eval "function ${cmd}(){ unset -f ${cmd}; load_nvm; ${cmd} \$@; }"
done

# add ffmpeg to path (and other homebrew binaries)
export PATH="/opt/homebrew/bin:$PATH"

# add flutter to path
export PATH="$PATH:/Users/miketobias/flutter/bin"

# for mac assistant repo
APPLE_ID=mike.tobias@timebyping.com

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
# [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# pnpm
export PNPM_HOME="/Users/miketobias/Library/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end

# deno
# . "/Users/miketobias/.deno/env"
#
# Load custom functions
# for file in ~/.zsh/functions/*.zsh; do
#   [[ -r "$file" ]] && source "$file"
# done

# secrets
source $HOME/.zshrc_env_vars

# [[ "$TERM_PROGRAM" == "kiro" ]] && . "$(kiro --locate-shell-integration-path zsh)"
#
export PATH="$HOME/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"

# Install or refresh ai-refactor (Taelin-style refactor workflow)
ai_refactor_install() {
  local root="${HOME}/.config/ai-scripts"
  if [ ! -d "${root}" ]; then
    echo "ai-scripts not found at ${root}. Clone or apply chezmoi first." >&2
    return 1
  fi

  if ! command -v bun >/dev/null 2>&1; then
    echo "bun is required. Install bun (https://bun.sh) and re-run." >&2
    return 1
  fi

  (cd "${root}" && bun install)

  mkdir -p "${HOME}/.local/bin"
  cat > "${HOME}/.local/bin/ai-refactor" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
cd "${HOME}/.config/ai-scripts"
exec bun run Refactor.ts "$@"
EOF
  chmod +x "${HOME}/.local/bin/ai-refactor"
  echo "ai-refactor installed. Ensure tokens exist at ~/.config/{openai,anthropic,google}.token"
}
